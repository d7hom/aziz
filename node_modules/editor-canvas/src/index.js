var { createCanvas, loadImage } = require("canvas");
///// Error log /////
var error = (err) => {
  throw new Error(err);
};
console.log(process.version)
///// Resize Text /////
function resizeText(ctx, { text, width, font }) {
  try {
    if (!ctx || !ctx.canvas) return error("resizeText: ctx not defined");
    if (!text) return error("resizeText: text can't be empty");
    if (!width || isNaN(Number(width))) width = ctx.canvas.width;
    else width = Number(width);
    text = text.toString();
    if (!font || isNaN(Number(font))) font = 20;
    else font = Number(font);
    let fontSize = font;
    do {
      ctx.font = `${(fontSize -= 2)}px `;
    } while (ctx.measureText(text).width > width);
    return ctx.font;
  } catch (e) {
    return error(`resizeText:\n ${e}`);
  }
}

///// Split Text /////
function splitText(ctx, { text, width, maxLine }) {
  try {
    if (!ctx || !ctx.canvas) return error("splitText: ctx not defined");
    if (!text) return error("splitText: text can't be empty");
    if (!width || isNaN(Number(width))) width = ctx.canvas.width;
    else width = Number(width);
    text = text.toString();
    var Width = ctx.measureText(text).width;
    var end = "";
    width = width - 10;
    var newText = text;
    if (Width > width) {
      newText = "";
      var times = Width / width;
      if (!maxLine || isNaN(Number(maxLine))) maxLine = times;
      else maxLine = Number(maxLine);
      var Times = Math.ceil(text.length / times);
      if (maxLine && times > maxLine) {
        times = maxLine;
        end += "â€¦";
      }
      for (let i = 0; i < times; i++) {
        newText += `${text.slice(
          i * Times,
          i == times ? text.length : Times * (i + 1)
        )}\n`;
      }
    }
    return `${newText.endsWith("\n") ? newText.slice(0, -1) : newText}${end}`;
  } catch (e) {
    return error(`splitText:\n ${e}`);
  }
}

///// Draw Circle /////
async function drawCircle(
  { image, stroke, fill, weight } = {
    fill: "BLACK",
    stroke: "BLACK",
    weight: 5,
  }
) {
  try {
    stroke = stroke ? stroke.toUpperCase() : null;
    fill = fill ? fill.toUpperCase() : null;
    weight = stroke
      ? weight && !isNaN(Number(weight))
        ? Number(weight)
        : 5
      : null;

    var canvas = new createCanvas(512, 512),
      ctx = canvas.getContext("2d"),
      x = weight,
      y = x,
      w = canvas.width - weight * 2,
      h = canvas.height - weight * 2;
    ctx.lineWidth = weight;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.beginPath();
    ctx.arc(x + w / 2, y + h / 2, Math.min(w, h) / 2, 0, Math.PI * 2, true);
    if (stroke) ctx.stroke();
    if (fill) ctx.fill();
    ctx.clip();

    if (image) {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      if (image) ctx.drawImage(image, x, y, w, h);
    }

    return canvas.toBuffer();
  } catch (e) {
    return error(`drawCircle:\n ${e}`);
  }
}

///// Draw Center /////
function drawCenter(ctx, img, x, y, w, h) {
  try {
    if (!ctx || !ctx.drawImage) return error("drawCenter: ctx not defined");
    if (!img || !isNaN(img)) return error("drawCenter: img not defined");
    var check =
      typeof x == typeof y &&
      typeof w == typeof h &&
      typeof x == typeof h &&
      typeof x == "number";

    if (!check)
      return error("drawCenter: coordinates can't be string or empty");
    if (img) {
      x -= w / 2;
      y -= h / 2;
      ctx.drawImage(img, x, y, w, h);
    }
  } catch (e) {
    return error(`drawCenter:\n ${e}`);
  }
}

///// Draw Square /////
async function drawSquare(
  { image, curve, stroke, fill, weight } = {
    curve: 20,
    stroke: "BLACK",
    fill: "BLACK",
    weight: 10,
  }
) {
  try {
    curve = curve && !isNaN(Number(curve)) ? Number(curve) : 20;
    weight = stroke
      ? weight && !isNaN(Number(weight))
        ? Number(weight)
        : 5
      : null;

    var canvas = new createCanvas(512, 512),
      ctx = canvas.getContext("2d"),
      x = weight,
      y = x,
      w = canvas.width - weight * 2,
      h = canvas.height - weight * 2;

    ctx.lineWidth = weight;
    ctx.strokeStyle = stroke ? stroke.toUpperCase() : null;
    ctx.fillStyle = fill ? fill.toUpperCase() : null;

    if (curve > w || curve > h) curve = Math.floor(Math.min(w, h) / 2);

    ctx.beginPath();
    ctx.moveTo(x + curve, y);

    ctx.lineTo(x + w - curve, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + curve);

    ctx.lineTo(x + w, y + h - curve);
    ctx.quadraticCurveTo(x + w, y + h, x + w - curve, y + h);

    ctx.lineTo(x + curve, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - curve);

    ctx.lineTo(x, y + curve);
    ctx.quadraticCurveTo(x, y, x + curve, y);
    if (stroke) ctx.stroke();
    if (fill) ctx.fill();
    ctx.clip();

    if (image) {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      if (image) ctx.drawImage(image, x, y, w, h);
    }
    return canvas.toBuffer();
  } catch (e) {
    return error(`drawSquare:\n ${e}`);
  }
}

///// Draw Polygone /////
async function drawPolygon(
  { image, angle, type, stroke, fill, weight } = {
    angle: 10,
    type: 1,
    stroke: "BLACK",
    fill: "BLACK",
    weight: 5,
  }
) {
  try {
    weight = stroke
      ? weight && !isNaN(Number(weight))
        ? Number(weight)
        : 5
      : null;
    angle = angle && !isNaN(Number(angle)) ? Number(angle) : null;
    type = type && !isNaN(Number(type)) ? Number(type) : 1;
    if (!angle || angle < 3 || angle > 20) {
      console.error("Angle must be a number between 3 and 20");
      angle = 10;
    }
    if (type < 1 || type > 3) type = 1;
    var canvas = new createCanvas(512, 512),
      ctx = canvas.getContext("2d"),
      angle = angle,
      width = canvas.width,
      height = canvas.height,
      typeOptions = [
        { x: width / 2, y: 5 },
        { x: (width / 3) * 2, y: 15 },
        { x: width / 3, y: 15 },
      ];
    type = typeOptions[type - 1];
    ctx.lineWidth = weight;
    ctx.strokeStyle = stroke ? stroke.toUpperCase() : null;
    ctx.fillStyle = fill ? fill.toUpperCase() : null;
    ctx.beginPath();
    ctx.moveTo(type.x, type.y + weight);
    for (let i = 0; i < angle + 1; i++) {
      ctx.translate(width / 2, height / 2);
      ctx.rotate(((360 / angle) * Math.PI) / 180);
      ctx.translate(-width / 2, -height / 2);
      ctx.lineTo(type.x, type.y + weight);
    }
    ctx.translate(width / 2, height / 2);
    ctx.rotate(((Math.ceil(angle) + 1) * (-360 / angle) * Math.PI) / 180);
    ctx.translate(-width / 2, -height / 2);
    if (stroke) ctx.stroke();
    if (fill) ctx.fill();
    ctx.clip();

    if (image) {
      try {
        image = await loadImage(image);
      } catch (e) {
        image = false;
      }
      if (image)
        ctx.drawImage(
          image,
          weight / 2,
          weight / 2,
          width - weight / 2,
          height - weight / 2
        );
    }
    return canvas.toBuffer();
  } catch (e) {
    return error(`drawPolygon:\n ${e}`);
  }
}

///// Resize Image /////
async function resizeImage({ image, width, height } = {}) {
  if (!image) throw new Error(`Image can't be not defined`);
  try {
    image = await loadImage(image);
  } catch (e) {
    image = false;
  }
  if (!image) return error("Invalid image");
  width = !width || isNaN(Number(width)) ? image.width : Number(width);
  height = !height || isNaN(Number(height)) ? image.width : Number(height);
  var canvas = new createCanvas(width, height),
    ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  return canvas.toBuffer();
}

///// Module(s) /////
module.exports.resizeText = resizeText;
module.exports.splitText = splitText;
module.exports.drawCircle = drawCircle;
module.exports.drawCenter = drawCenter;
module.exports.drawSquare = drawSquare;
module.exports.drawPolygon = drawPolygon;
module.exports.resizeImage = resizeImage;
